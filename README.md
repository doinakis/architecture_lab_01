# architecture_lab_01
## **Πρώτο εργαστήριο αρχιτεκτονικής υπολογιστών (ΤΗΜΜΥ ΑΠΘ)** 

### Εισαγωγή

Στο πρώτο εργαστήριο μας ζητήθηκε να χρησιμοποιήσουμε τον gem5 για να εκτελέσουμε ένα απλό πρόγραμμα τύπου _"Hello World"_ προκειμένου να εξοικειωθούμε με τη χρήση του προσομοιωτή και να μάθουμε να αλλάζουμε, αλλά και να διαβάζουμε, τις διάφορες παραμέτρους από έναν επεξεργαστή.Ο gem5 έχει τη δυνατότητα να προσομοιώση και _Full System_ δηλαδή ένα πλήρες σύστημα και να εκτελέσει ενα πλήρες λειτουργικό σύστημα,ή να κάνει ενα _System Call Emulation_ δηλαδή να προσομοιώσει μόνο τον επεξεργαστή και το υποσύστημα της μνήμης.    

### Βασικές παράμετροι (με τη χρήση της starter_se.py)

  Ανοίγοντας το αρχείο _starter_se.py_ παρατηρούμε τα τρία διαφορετικά είδη cpu που μπορούμε να χρησιμοποίσουμε με τη συγκεκριμένη βιβλιοθήκη.Στη περίπτωση μας,εφόσον έχουμε τρέξει την εντολή _$ ./build/ARM/gem5.opt -d hello_result configs/example/arm/starter_se.py --cpu="minor" "tests/test-progs/hello/bin/arm/linux/hello"_ , έχουμε χρησιμοποιήσει το _flag --cpu="minor"_ άρα ήδη μπορούμε να βγαλουμε συμπεράσματα για τα είδη των _cache_ που χρησιμοποιεί ο συγκεκριμένος επεξεργαστής: 
* level 1 instruction cache 
* level 1 data cache 
* Walk Cache και 
* level 2 cache
* chache line size = 64kB.  
  Παράλληλα με τη χρήση της συγκεκριμένης βιβλιοθήκης τίθεται το **_Source Clock Domains_** στα 1 GHz και το **_Voltage Domain_** στα 3.3V.Το πρώτο διατηρεί την περίοδο ρολογιού και παρέχει μεθόδους για τη ρύθμιση / λήψη του ρολογιού και των παραμέτρων διαμόρφωσης που θα διαχειριστεί ο _handler_ όπως π.χ τιμές συχνότητας σε διάφορα επίπεδα απόδοσης. To _Voltage Domain_ χρησιμοποιείται για να ομαδοποιήσει τα _clock domains_ να λειτουργόυν κάτω από το ίδιο _voltage_, και παρέχει μεθόδους τόσο για τη ρύθμιση όσο και για τη λήψη του.  
Όπως παρατηρούμε και από την εντολή που εκτελέσαμε, η μόνη παράμετρος που θέσαμε είναι ο τύπος του επεξεργαστή που θα χρησιμοποιήσουμε (με το _flag --cpu="minor"_).Τι συμβαινει όμως με τις υπόλοιπες παραμέτρους του επεξεργαστή που δεν θέσαμε;Αν δεν βάλουμε συγκεκριμένες τιμές για τη συχνότητα, τον αριθμό των βασικών μονάδων, του τύπου της μνήμης κτλ η συγκεκριμένη βιβλιοθήκη δίνει κάποιες _default_ τιμές για οτιδήποτε δεν έχουμε καθορίσει.Παρέχει όμως τη δυνατότητα αλλαγής των συγκεκριμένων τιμών με τα κατάλληλα _flags_ ακριβώς όπως χρησιμοποιήσαμε και για τον τύπο του επεξεργαστή.Οι _default_ τιμές είναι οι εξής(σε παρένθεση εμφανίζονται τα _flags_ με τα οποία μπορούμε να αλλάξουμε τις τιμές) :
* Cpu frequency = 4GHz (_--cpu-freq_)
* Number of cores = 1 (_--num-cores_)
* Memory type = DDR3_1600_8x8 (_--mem-type_)
* Memory channels = 2 (_--mem-channels_)
* Memory ranks = None (_--mem-ranks_)
* Memory size = 2 GB (_--mem-size_)

### Επαλήθευση των παραμέτρων (με βάση τα αρχεία _config.ini config.json_)

#### Αρχείο _config.ini_
  Ανοίγοντας τώρα το αρχείο _config.ini_ το πρώτο πράγμα που παρατηρούμε είναι το **_[root]_** και κοιτώντας την παράμετρο **_full_system=false_** καταλαβαίνουμε ότι όντως πρόκειται για μία εξομοίωση όχι ενός ολοκληρωμένου συστήματος αλλά μόνο προσομοίωση του επεξεργαστή και των υποσυστημάτων μνήμης. Συνεχίζοντας την ανάγνωση βλέπουμε ένα ακόμα "αντικείμενο" με το όνομα **_[system]_** το οποίο έχει ως "παιδία" το **_clock domain_**,το **_voltage domain_** τα οποία αναφέρθηκαν παραπάνω το **_cpu_cluster_** το **_memory bus_** καθώς και το γεγονός ότι έχουμε .Επιπλέον, παρατηρούμε ότι το **_system_** είναι παιδί του **_root_**. Το _system_ μας δίνει πληροφορίες τόσο για το **_cache line size_ = 64 kB**, όπως είχαμε δει και στο **_starter_se.py_** αρχείο, αλλά μας δίνει και άλλες πληροφορίες σχετικά με το αν υποστηρίζεται _multi threading_, που στη περιπτωσή μας δεν υποστηρίζεται αφού έχουμε μονοπύρηνο επεξεργαστή, με τo ότι έοχουμε _dual channel memory_ (**_memories=system.mem_ctrls0 system.mem_ctrls1_**) και άλλα.Όσον αφορά το _Source Clock Domains_ βρίσκεται στην ενότητα **_[system.clk_domain]_** και είναι ίσο με **_clock_=1000** ticks τα οποία αντιστοιχούν σε **1000000000000/1000=1GHz**, όσο αναμέναμε δηλαδή.Λίγο πιο κάτω στην ενότητα **_[system.cpu_cluster.clk_domain]_** βλέπουμε τη συχνότητα του επεξεργαστή **_clock_=250** ticks δηλαδή **1000000000/250=4GHz**, και στη συνέχεια στην **_[system.cpu_cluster.cpus]_** βλέπουμε πλέον πληροφορίες που έχουν να κάνουν με τον τύπο του επεξεργαστή (**_type=MinorCPU_**) αλλά και τον αριθμό των threads (**_numThreads=1_**).Επιπλέον, από τα "παιδιά" της ενότητας αυτής παίρνουμε πληροφορία σχετικά με τα είδη της _cache_ θα έχουμε _data cache_(**dcache**), _instruction cache_(**icache**) και _walker cache_(**dtb_walker_cache & itb_walker_cache**), αλλά και _level 2 cache_ που φαίνεται παρακάτω στην ενότητα (**_[system.cpu_cluster.l2]_**) .Κάθε είδος _cache_ έχει αργότερα τη δική του ενότητα που περιγράφει αναλυτικά τις προδιαγραφές τους π.χ αν υπάρχει _associativity_ το μέγεθος το _indexing_ και ότι αφορά το κάθε είδους _cache_.Το _voltage domain_ φαίνεται στην ενότητα **_[system.voltage_domain]**_ και έχει τιμή **_voltage=3.3_**.
  
  #### Αρχείο _config.json_
  Ουσιαστικά και το αρχείο _congif.json_ περιέχει ακριβώς τις ίδιες πληροφορίες με το αρχείο -config.ini_ απλά σε διαφορετική μορφή.Η αλήθεια είναι πως το το _config.ini_ είναι πιο ευανάγνωστο σε σχέση με το άλλο. 
  #### Επιπλέον αρχεία 
  Παράλληλα, με τα παραπάνω αρχεία ο gem5 δίνει ακόμα και μια γραφική αναπαράσταση του επεξεργαστή που έτρεξε το πρόγραμμα μας,στο οποίο φαίνονται και τα caches και ο τύπος της ram που χρησιμοποιήθηκε,καθώς και ένα αρχείο με στατιστικά για το πρόγραμμα που εκτελέστηκε,το οποίο θα το δούμε και παρακάτω.
  Γενικότερα, τα αρχεία που βγαίνουν μετά την ολοκλήρωση της προσομοίωσης απο το gem5 είναι ιδιαίτερα σημαντικά.Τα _config_ αρχεία μας επιτρέπουν να βεβαιωθούμε ότι η προσομοίωση έτρεξε ακριβώς με τις προδιαγραφές τις οποίες είχαμε θέσει πριν ξεκινήσουμε την προσομοίωση και να βεβαιωθούμε ότι δεν έχει γίνει κάποιο λάθος.Το αρχείο με τα στατιστικά είναι ακριβώς ο λόγος για τον οποίο τρέχουμε το πρόγραμμα μας στον _gem5_, για να δούμε τη συμπεριφορά του επεξεργαστή ή ενός ολόκληρου λειτουργικού όταν τρέχει σε αυτό το προγραμμά μας, τον χρόνο τα _cache misses_ και πολλές άλλες παραμέτρους που παρουσιάζονται μέσα σε αυτό.Όσο για τη γραφική αναπαράσταση που δίνει μας δίνει μια συνολική εικόνα για το σύστημα για το οποίο τρέξαμε την προσομοίωση.
  
  ### _Gem5 in-order CPUs_ (HPI)
  #### _MinorCPU_
  Ένα από τα μοντέλα _in-order CPUs_ είναι και ο _MinorCPU_ που χρησιμοποιήσαμε παραπάνω για την εκτέλεση του _hello world_ προγραμματός.Ο _Minor_ είναι ένας _in order CPU_ ο οποίος έχει σταθερό _pipeline_, αλλά δυναμικές δομές δεδομένων και εκτελεστική συμπεριφορά.Χρησιμοποιείται κυρίως για αυστηρά _in order_ συμπεριφορές και επιτρέπει την απειόνιση μιας εντολής στο _pipeline_ μέσω του _MinorTrace/minorview.py format/tool_.Σκοπός του είναι να δοθεί ένα πλαίσιο για την αρχιτεκτονική προσέγγιση του μοντέλου με έναν συγκεκριμένο επεξεργαστή με παρόμοιες ιδιότητες.Το μοντέλο αυτό δεν υποστηρίζει ακόμα _multithreading_ αλλά υπάρχουν _THREAD comments_ σε συγκεκριμένα σημεία όπου τα εκάστοτε δεδομένα χρειάζεται να προσαρμοστούν για να υποστηρίξουν _multithreading_.Χρησιμοποιεί _pipeline_ τεσσάρων σταδίων:
  * _fetch1_
  * _fetch2_
  * _decode_
  * και _execute_  
Για περισσότερες πληροφορίες αναλυτικά με το _pipeline_ το πώς γίνονται _issue_ οι εντολές πώς γίνεται το commit πώς γίνεται fetch κτλ το _site_ του _gem5_ έχει όλες τις πληροφορίες [**εδώ**](http://pages.cs.wisc.edu/~swilson/gem5-docs/minor.html).

 #### _SimpleCPU_
 Το μοντέλο _SimpleCPU_ είναι ένα μοντέλο ιδανικό όταν δεν είναι απαραίτητο ένα πλήρες και λεπτομερές μοντέλο.Αυτό μπορεί να περιλαμβάνει _warm up periods_ ή απλά μια επιβαιβέωση ότι το πρόγραμμα δουλεύει.Πλέον έχει χωριστεί σε τρεις κατηγορίες:
 * _BaseSimpleCPU_
 * _AtomicSimpleCPU_
 * _TimingSimpleCPU_  
 To _BaseSimpleCPU_ δεν μπορεί να λειτουργήσει αυτόνομο, αλλά πρέπει να χρησιμοποιηθει μαζί του και ένα από τα άλλα 2 μοντέλα. 
 Ο _AtomicSimpleCpu_ είναι η έκδοση του _SimpleCPU_ που χρησιμοποιεί _atomic memory accesses_, δηλαδή πιο γρήγορες "επισκέψεις"  στη μνήμη από ότι ένα λεπτομερές _access_.Αυτού του είδους τα _accesses_ χρησιμοποιούνται για να μεταβαίνουν πιο γρήγορα σε διαφορετικές καταστάσεις τους συστήματος (_fast forwarding_) και για να "προθερμαίνουν" τις _caches_ και επιστρέφουν έναν προσεγγιστικό χρόνο για να ολοκληρώσουν το ζητούμενο χωρίς καμία καθυστέρηση.Όταν καλείται ένα _atomic access_ η απάντηση σε αυτό παρέχεται όταν ολοκληρωθεί η συνάρτηση.Η _AtomicSimpleCpu_ χρησιμοποιεί τις προσεγγίσεις των καθυστερήσεων απο τα _atomic accesses_ για να υπολογίσει τον συνολικό _access time_ στη _cache_.Χρησιμοποιείται μαζί με τον _BaseSimpleCPU_ και παρέχει τις συναρτήσεις για τα _read_ και _write_ στη μνήμη και στο _tick_ που καθορίζει τι γίνεται σε κάθε κύκλο.Επιπλέον, ορίζει την "δίοδο" που προσαρτεί τη μνήμη και συνδέει τον επεξεργαστή με την _cache_.[_AtomicSimpleCPU_](http://www.m5sim.org/wiki/images/e/e5/AtomicSimpleCPU.jpg)  
 Ο _TimingSimpleCPU_ είναι η έκδοση που χρησιμοποιεί _timing memory accesses_, δηλαδή τις πιο λεπτομερείς "επισκέψεις" στη μνήμη.Είναι πρακτικά η πιο ρεαλιστική περίπτωση και περιλαμβάνει και τις καθυστερήσεις ουράς αλλα και αν δεν είναι διαθέσιμο κάποιο κομάτι _hardware_. Μετά που ζητηθεί ένα _timing request_ κάποια στιγμή η συσκευή που το έστειλε θα λάβει μία απάντηση σε αυτό που ζήτησε ή ένα _NACK_  αν αυτό που ζητήθηκε δν μπόρεσε να ολοκληρωθεί.(Γενικά _timing_ και _atomic accesses_  δεν μπορούν να συνυπάρχουν σε ένα σύστημα.Ο _TimingSimpleCPU_, λοιπόν κάνει _stall_ σε κάθε _access_ στη _cache_ και περιμένει την μνήμη του συστήματος να "απαντήσει" για να συνεχίσει.Ὀπως και η _AtomicSimpleCPU_ xρησιμοποιείται μαζί με τον _BaseSimpleCPU_ και παρέχει τις συναρτήσεις για τα _read_ και _write_ στη μνήμη και στο _tick_ που καθορίζει τι γίνεται σε κάθε κύκλο.Επιπλέον, ορίζει την "δίοδο" που προσαρτεί τη μνήμη και συνδέει τον επεξεργαστή με την _cache_.[_TimingSimpleCPU_](http://www.m5sim.org/wiki/images/f/f8/TimingSimpleCPU.jpg)  
 #### _High performance in-order CPU_
 Το μοντέλο _HPI_ έχει ακριβώς την ίδιο _pipeline_ τεσσάρων σταδίων που έχει και ο _MinorCPU_. Το _timing_ μοντέλο που χρησιμοποιεί είναι αντιπροσωπευτικό για έναν μοντέρνο _in-order Armv8-A_.Πληροφορίες πιο αναλυτικές σχετικά με τα _caches_,το _pipeline_, τη διαχείριση της μνήμης και για πληροφορίες και για τα προηγούμενα μοντέλα μπορούν να βρεθούν [εδώ](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=3&ved=2ahUKEwjA0oi7kvblAhVFI1AKHTz-AC4QFjACegQIBBAC&url=https%3A%2F%2Fraw.githubusercontent.com%2Farm-university%2Farm-gem5-rsk%2Fmaster%2Fgem5_rsk.pdf&usg=AOvVaw1pjkMJ--WpHuBWZmcFiV3q).
